# 复杂度
o(log n)的复杂度无限接近于o(1)
关于级数的问题：
算数级数
1 + 2 + 3 + ... + n = o(n^2)
幂方级数： 比幂的方次高出一阶
1^2 + 2^2 + 3^2 + ...+ n^2 = o(n^3)
几何级数：与末项同阶
2^0 + 2^1 + 2^2 + 2^3 + .... + 2^n = o(2 ^ n)
收敛级数：
收敛级数不会超过某个上界，对应的复杂度是o(1)
调和级数：
1 + 1/2 + 1/3 + ... + 1/n = o(log n)
对数级数：
log 1 + log 2 + log 3 + ... + log n = o(nlog n)
# 一些数据结构的复杂度理解
list在最后插入一个元素，复杂度为o(1)，但是在头部插入一个元素，复杂度为o(n)，因为在头部插入时，所有的元素都要后移。
# 栈的典型应用场合
## 逆序输出（输出次序与处理过程颠倒；递归深度和输出长度不易预知）
### 十进制转换为二进制
通过不断的除以2，把余数记录在一个stack中，直到被除数为0，然后栈中的值弹出即为所转换的二进制数目
## 递归嵌套（具有自相似性的问题可递归描述，但分支位置和嵌套深度不固定）
### 括号匹配问题
遍历过程中遇到括号就压栈，遇到匹配的括号则弹栈，要求弹出括号和所匹配的成对出现。最后栈为空的话则匹配成功。
## 延迟缓冲（线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀）
### 表达式求值问题 中缀表达式求值
需要定义好运算符的优先级，只有当前运算符比之前的运算符优先级更低的时候才计算上一个。
### 逆波兰表达式问题（RPN）
不需要定义运算符的优先级，只需要不停的从表达式中取值，数字压栈，运算符计算之后压栈。
中缀表达式可以转换成逆波兰表达式。思路同中缀表达式求值一样。数字直接append，只有当前操作符比栈定操作符优先级低的时候，弹出栈顶元素，append弹出的操作符。
# 树
树是列表和链表的的一种结合。列表搜索元素复杂度为o(log n)，添加元素复杂度为o(n)；链表搜索元素为o(n)，添加元素复杂度为o(1)。树作为集成两者长处的一种数据结构而产生。
树的任一节点与根节点之间有唯一路径，路径的长度称为该节点的深度。path（v）上的点都是v的祖先，v是他们的后代。除了自身外，是真祖先/后代。
树的半线性：在任一节点，若是祖先/后代存在，那么祖先唯一，后代不一定唯一。
树是无环联通图。极小联通图，极大无环图。
树的表示可以使用长子，兄弟法来进行描述。
## 二叉树  
先序遍历 中序遍历 后续遍历指的是根节点的前中后。先序遍历就是 根 左 右
树是半线性结构，可以通过遍历转换成功线性结构
# 图
图是非线性结构，可以通过遍历转换成半线性结构
