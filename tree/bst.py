# @Time : 2021/3/25 11:12 
# @Author : lilong
# @File : bst.py 
# @Description:
from tree import BinTree

# bst搜索，实际上就是二分查找，实际返回定位到的节点以及父节点
def bst_search(node, data, f_node=None):
    if node.data == data or node.data is None:
        return node, f_node
    else:
        return bst_search(node.l_child, data, node) if node.data > data else bst_search(node.r_child, data, node)

# 这里所构建的bst树中的空节点其实是data为None的BinTree节点
# 插入实际上就是把搜索接口返回的定位到的节点指向索要插入的点
def bst_insert(node, data):
    s_node, f_node = bst_search(node, data)
    s_node.data = data
    print(f_node)

# 删除：如果待删除的节点的右子树为空，那么就把左子树连接到其父节点；如果左子树为空，那么就把右子树连接到其父节点；如果有两个子树，
# 情况稍微复杂，需要把待删除的节点与其直接后继交换位置，交换之后如果待删除的节点没有子树，直接删除，如果有（只能是一个右子树），
# 删除之后把其右子树放在已删除节点的位置

# bst不平衡时可以通过一定的算法转换成bbst


##   avl树
# avl树：任意一个节点两个子树的高度差<=1，是一种适度平衡的bst。
# avl可以直接使用bst的搜索接口，但是插入和删除接口需要重构，因为插入或者删除之后，接口可能变得不平衡了
# 插入一个节点，可能会导致失衡的节点：父节点以及祖先节点，其他节点不会失衡
# 删除一个节点，可能会导致失衡的节点：只有这个节点的父节点
# 插入一个节点导致的失衡，通过旋转来进行重平衡。而且子节点的修复成功之后，父节点的失衡也随之修复（修复后的子树高度不变）
# 由于删除节点导致的失衡，也是通过旋转来进行调整，但是调整之后，子树的高度可能会改变，因此可能会导致更高的祖先节点失衡，需要对祖先再次进行旋转，
# 最差需要旋转o(log n)次
# 所谓各种方式的旋转本质就是3 + 4重平衡，3是指失衡节点紧随其后的两个较高的节点，4是指4棵子树。所要做的其实就是把3个节点放在4棵子树中间。
# avl树优点：无论是查找，插入还是删除，时间复杂度最坏都是log n，使用了n的存储空间
# 缺点：借助了高度和平衡因子，需要改造元素的结构，或者额外封装；删除操作最多需要进行log n次转；

##   伸展树
# 我们访问了某个节点，该节点很大概率还会被接着访问。所以在bst中可以通过一种策略把刚刚被访问的节点放在更容易被搜索到的位置，比如树根处：通过旋转
# 的方式使得该被访问的节点逐层上升，动态来看就是一棵树不断进行伸展的过程
# 另外一种使得节点逐层上升的方式是：每次不只关注他的父节点，还有他的祖先节点，三个节点旋转2次使得该节点到达祖先节点的位置。逐层上升的旋转方式：每次
# 都以父节点为根节点进行旋转；刚刚提到的上升方式：先以祖父节点为根节点进行旋转，使得该节点和父亲节点上升一层，祖父节点下降一层；再以父节点为根节点
# 进行旋转，使得子节点上升到原来祖父节点的位置
# 通过这种旋转方式在某种情况下可以使得树的深度变浅，从而优化bst的性能。
# 伸展树的查找接口：如果找到，把找到的节点上升到根节点；如果未找到，空节点位置处的父节点上升到根节点
# 伸展树的新增接口，先调用查找接口，（未找到），完成之后树已经进行的伸展，只要把节点新增在树的根节点即可
# 删除接口，先调用查找接口，该节点上升到根节点，删除根节点（找到根节点的直接后继作为新的根节点）

##   B树
# 平衡的多路搜索树，经过适当合并，得到超级节点。每两代合并：4路；每3代合并：8路；每d代合并，m=2^d路，有m-1个关键码
# 假如有1g的记录，每次查找需要进行log 2 10^9 = 30次io，每次只能读出一个k，每次io都非常耗时，得不偿失。但是B树每次可以读出一组超级key，这一组
# key包含m-1个值。每组超级key的数目取决于：磁盘数据块的大小 / 每个key的大小。尽量保证每次io拿到一个数据块的数据
# B树路数为m，每个节点的分支数的上下界为【m/2, m】，m / 2取上界
# 查找接口 假如根节点已经保存在内存中，且保存形式为节点的列表以及引用的列表。搜索的时候首先在根节点中查找，没找到的话，再从外存中把下一层节点的
# 一组key加载到内存（进行了一次io操作），继续查找。
# 包含N个关键码的m阶B树的最大树高：h <= 1 + log (m/2) ((N + 1 / 2)), 也就是o(log m N)。
# 相对于bbst，1 + log (m/2) ((N + 1 / 2))    /     log 2 N =  1 / (log 2 m   - 1), 若是m = 256, 树高降低为 1 / 7.大大减少了io次数
# 对于非常耗时的io操作来说，1天与7天的差别是巨大的
# 通过同样的计算，包含N个关键码的m阶B树的最大树高，如果m = 256，树高约为之前的1 / 8. 可以看出当关键码的总数固定时，总树高的变化范围不大。
# 分裂。当插入一个关键码时，可能会导致该节点数目超出m，此时需要进行分裂，取中位数插入到父节点，原来的节点分裂为两个，作为中位数节点的左右引用。
# 插入之后可能导入父节点关键码超出，需要继续分裂。最多不过h次
# 删除算法。先查询该节点，若是叶子的话直接删除；不是叶子的话，找到该节点的右子树然后一直向左，找到直接后继，交换位置之后再进行删除。删除之后有可能
# 出现下溢，解决方案：旋转：发生下溢的节点首先查看其兄弟的节点是否>=m/2，如果满足条件的话，把两者的父节点转移到下溢节点的最左侧，把兄弟节点的最
# 右侧节点转移到父节点。如果不存在的话：则是新增时候的逆过程，从父节点拿一个关键码，然后与自己合并后再与兄弟合并，如果父节点因此也下溢，那么持续以上
# 的过程


##  红黑树
# 定义：统一增加外部节点使其成为真二叉树，1.根节点是黑的，2.外部节点都是黑色，3.每个红色节点的父亲与孩子都是黑的
# 4. 每个外部节点到根节点的通路上黑色节点数目一致。
# 提升变换：把每个红色的节点都提升到与他的父亲平级
# 红黑树经过提升变换其实就是（2，4）B树
# 插入接口：调用标准bst的搜索接口，假定不存在，然后创建一个红节点作为hot的子节点，如果有必要的话，进行双红修正。
# 双红修正：插入的节点是红色的叶子节点x，其父节点p为色，祖父节点g一定是黑色。
# 假如该红节点的叔父节点是黑色，对x, p, g以及其4棵子树做3 + 4重构，并且把中间设置为黑色，两边设置为红色。
# 当叔父节点是红色的时候，首先做一下提升变换（所有指向红色节点的边收缩到同一个超级节点），提升之后可以发现是一个非法的4路B树，这个时候出现了
# 上溢，需要进行B树的上溢处理。处理完成之后，有可能会再次出现双红缺陷，继续沿用之前的方法即可。虽然看上去B树的拓扑结构变化了，实际上红黑树的
# 拓扑结构并没有改变，只是进行了重染色操作。
# 复杂度：叔父节点为黑色的时候，只要进行至多两次旋转+染色操作；为红色的时候，不需要进行旋转，最多进行log n次染色。两者的重构次数都是常数次。
# 删除算法：使用bst的经典删除算法，删除x节点，替换节点为r，假如其中有一个是红色，则只需要把r染成黑色即可；假如x和r都是黑色，删除x之后，必然
# 导致黑高度不一样。第一种情况，x的兄弟为黑色，且x的兄弟至少有一个红孩子t，此时t s p与4棵子树做3 + 4变换，t p都变黑色，s继承之前p的颜色，此时
# 树的总体黑高度不变；第二种情况，x的兄弟为黑色，且x的兄弟的两个孩子都是黑色，且x的父节点为红色：转换成b树，删除节点后实际上就是发生了下溢，此时
# 解决下溢问题即可，直接看染色的操作就是：p红转黑，s由黑转红，总体的黑高度不变；第三种情况：x的兄弟为黑色，且x的兄弟的两个孩子都是黑色，
# 且x的父节点为黑色，转换为b树之后，删除，发生下溢，解决下溢之后再转换为红黑树，发现下溢会持续向上进行，最多log n次，但是实际上树的拓扑结构不会
# 改变，只是进行了一系列的重染色操作；第四种情况，x的兄弟的节点为红色，经过拓扑结构的变化之后，变成之前的情况，方便处理。

# 散列
# 数组加链表。散列函数需要使其尽可能的均匀。如果使用取模运算的话，除数为素数时会分布的更加均匀。
# 由于链表的数据在空间上不是连续的，当数据量非常大的时候，很难有效的利用系统的缓存功能，当需要进行io的时候，效率更加低下





if __name__ == '__main__':
    tree = BinTree.build_tree([16, 10, 25, 5, 11, 19, 28, 2, 8, None, 15, 17, 22, 27, 37, None, 4, None, None, 13, None, None, None, None, None, None, None, 33, None])
    # print(tree)
    n, f = bst_search(tree, 40)
    # print(n, f)
    # bst_insert(tree, 40)


